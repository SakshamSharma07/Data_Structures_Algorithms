# Mobile Numeric Keypad Problem

## Problem Description

You are tasked with calculating the number of unique sequences of a given length ùëõ that can be generated by pressing buttons on a mobile phone's numeric keypad. The keypad is laid out in a 3x3 grid, excluding the bottom row corners (* and #). Each digit on the keypad (0-9) can only move to neighboring digits directly up, down, left, or right. 
- For example, pressing 5 allows subsequent presses of 2, 4, 6, and 8. However, diagonal movements and presses of the bottom row corner buttons are prohibited.
- Given an integer ùëõ, your goal is to determine how many distinct sequences of length ùëõ can be formed starting from any digit on the keypad.

## Input

An integer ùëõ (1 ‚â§ ùëõ ‚â§ 25), represents the desired length of the sequences.

## Output

An integer representing the total number of unique sequences of length ùëõ that can be generated using the rules of the keypad.

## Examples

### Example 1:
Input: ùëõ = 1  
Output: 10  
Explanation: There are 10 possible sequences of length 1 (0, 1, 2, 3, 4, 5, 6, 7, 8, 9).

### Example 2:
Input: ùëõ = 2  
Output: 36  
Explanation: There are 36 possible sequences of length 2. For instance, starting from 0, valid sequences include 00, 08, 01, 04, etc.

## Constraints

1 ‚â§ ùëõ ‚â§ 25

## Approach

### Problem Understanding

The task is to count the number of possible unique sequences of length ùëõ that can be formed starting from any digit on the keypad, following the allowed moves.

The allowed moves for each digit are defined as follows:
- From 0, you can move to 0 or 8.
- From 1, you can move to 1, 2, or 4.
- From 2, you can move to 1, 2, 3, or 5.
- From 3, you can move to 2, 3, or 6.
- From 4, you can move to 1, 4, 5, or 7.
- From 5, you can move to 2, 4, 5, 6, or 8.
- From 6, you can move to 3, 5, 6, or 9.
- From 7, you can move to 4, 7, or 8.
- From 8, you can move to 0, 5, 7, 8, or 9.
- From 9, you can move to 6, 8, or 9.

### Approach 1: Memoization + Recursion

We define a recursive function `countSequences(length, digit)` that computes the number of sequences of a given length ending with a specific digit. The function works as follows:

1. **Base Case:** If the sequence length is 1, there is exactly one sequence for each digit (itself), so we return 1.
2. **Memoization Check:** Before calculating the result for `countSequences(length, digit)`, we check if it is already computed and stored in `dp[length][digit]`. If it is, we return the stored result to avoid redundant calculations.
3. **Recursive Calculation:** If not already computed, we calculate the total number of sequences by summing the results of the recursive calls for all possible moves from the current digit.
4. **Store Result:** We store the computed result in `dp[length][digit]` before returning it to avoid redundant calculations in future calls.

**Time Complexity:** O(n) where n is the length of the sequence.  
**Space Complexity:** O(n) due to the memoization table.

### Approach 2: Tabulation (Bottom-up Dynamic Programming)

1. Use a 2D array `dp[length][digit]` where `dp[i][j]` represents the number of sequences of length i ending with digit j.
2. **Initialization:** Initialize `dp[1][j]` to 1 for all digits j since there's exactly one sequence of length 1 ending with each digit.
3. **Iteration:** For lengths from 2 to n and for each digit, compute `dp[length][digit]` by summing results for all allowed moves from the current digit.

**Time Complexity:** O(n) where n is the length of the sequence.  
**Space Complexity:** O(n) due to the dynamic programming table.

---

These two approaches provide efficient solutions to count the number of unique sequences of a given length on a mobile keypad, leveraging memoization and tabulation techniques respectively. Adjustments to the allowed moves and the keypad layout can be accommodated by modifying the `arr` array in both approaches.

