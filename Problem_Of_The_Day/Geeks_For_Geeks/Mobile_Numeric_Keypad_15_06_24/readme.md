# Approach to Problem Mobile Numeric Keypad

## Problem Description
You are tasked with calculating the number of unique sequences of a given length ùëõ that can be generated by pressing buttons on a mobile phone's numeric keypad. The keypad is laid out in a 3x3 grid, excluding the bottom row corners (* and #). Each digit on the keypad (0-9) can only move to neighboring digits directly up, down, left, or right.For example, pressing 5 allows subsequent presses of 2, 4, 6, and 8. However, diagonal movements and presses of the bottom row corner buttons are prohibited.Given an integer n, your goal is to determine how many distinct sequences of length n can be formed starting from any digit on the keypad.

## Input
An integer n (1 ‚â§ n ‚â§ 25), representing the desired length of the sequences.

## Output
An integer representing the total number of unique sequences of length n that can be generated using the rules of the keypad.

## Examples
### Example 1:
Input: ùëõ=1
Output: 10 
Explanation: There are 10 possible sequences of length 1 (0, 1, 2, 3, 4, 5, 6, 7, 8, 9).
#### Example 2:
Input: n=2
Output: 36
Explanation: There are 36 possible sequences of length 2. For instance, starting from 0, valid sequences include 00, 08, 01, 04, etc.

## Constraints
1 ‚â§ n ‚â§ 25

## Approach
### Problem Understanding
The task is to count the number of possible unique sequences of length n that can be formed starting from any digit on the keypad, following the allowed moves.

The allowed moves for each digit are defined as follows:
From 0, you can move to 0 or 8.
From 1, you can move to 1, 2, or 4.
From 2, you can move to 1, 2, 3, or 5.
From 3, you can move to 2, 3, or 6.
From 4, you can move to 1, 4, 5, or 7.
From 5, you can move to 2, 4, 5, 6, or 8.
From 6, you can move to 3, 5, 6, or 9.
From 7, you can move to 4, 7, or 8.
From 8, you can move to 0, 5, 7, 8, or 9.
From 9, you can move to 6, 8, or 9.

### Approach 1: Memoization + Recursion

We define a recursive function countSequences(length, digit) that computes the number of sequences of a given length ending with a specific digit. The function works as follows:

Base Case: If the sequence length is 1, there is exactly one sequence for each digit (itself), so we return 1.
Memoization Check: Before calculating the result for countSequences(length, digit), we check if it is already computed and stored in dp[length][digit]. If it is, we return the stored result to avoid redundant calculations.
Recursive Calculation: If not already computed, we calculate the total number of sequences by summing the results of the recursive calls for all possible moves from the current digit.
Store Result: We store the computed result in dp[length][digit] before returning it to avoid redundant calculations in future calls

Time Complexity : This time Complexity is  O(n√ó10√ó5),   which further simplifies to O(n), since 10 and 5 are constants.
Space Complexity : The overall space complexity is O(n√ó10), which simplifies to O(n).

### Approach 2: Tabulation (Bottom-up Dynamic Programming)
Use a 2D array dp[length][digit] where dp[i][j] represents the number of sequences of length i ending with digit j.
Initialization: Initialize dp[1][j] to 1 for all digits j since there's exactly one sequence of length 1 ending with each digit.
Iteration: For lengths from 2 to n and for each digit, compute dp[length][digit] by summing results for all allowed moves from the current digit.
Time Complexity: O(n) where n is the length of the sequence.
Space Complexity: O(n) due to the dynamic programming table.

## Solution Code
```cpp
// Include your code here
